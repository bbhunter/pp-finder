#! /usr/bin/env node
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 5063:
/***/ ((module) => {

"use strict";


module.exports = ({onlyFirst = false} = {}) => {
	const pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
};


/***/ }),

/***/ 2068:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* module decorator */ module = __nccwpck_require__.nmd(module);


const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = __nccwpck_require__(6931);
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});


/***/ }),

/***/ 8818:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const ansiStyles = __nccwpck_require__(2068);
const {stdout: stdoutColor, stderr: stderrColor} = __nccwpck_require__(9318);
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = __nccwpck_require__(2415);

const {isArray} = Array;

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
			return applyStyle(builder, chalkTag(builder, ...arguments_));
		}

		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!isArray(firstString) || !isArray(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = __nccwpck_require__(500);
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

module.exports = chalk;


/***/ }),

/***/ 500:
/***/ ((module) => {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

module.exports = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMessage);
	}

	return chunks.join('');
};


/***/ }),

/***/ 2415:
/***/ ((module) => {

"use strict";


const stringReplaceAll = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

module.exports = {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
};


/***/ }),

/***/ 4413:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.safeAsync = exports.isErr = exports.isOk = exports.err = exports.ok = void 0;
function ok(value) {
    return { _tag: 'ok', value };
}
exports.ok = ok;
function err(error) {
    return { _tag: 'error', error };
}
exports.err = err;
/**
 * Checks whether a value is an `Ok`.
 * Handy with TypeScript guards
 */
function isOk(result) {
    return result._tag === 'ok';
}
exports.isOk = isOk;
/**
 * Checks whether a value is an `Err`.
 * Handy with TypeScript guards
 */
function isErr(either) {
    return either._tag === 'error';
}
exports.isErr = isErr;
/**
 * Convert a `Promise<T>` into a `Promise<Result<Error, T>>`,
 * therefore catching the errors and being able to handle them explicitly
 */
async function safeAsync(promise) {
    try {
        const value = await promise;
        return ok(value);
    }
    catch (e) {
        return err(e);
    }
}
exports.safeAsync = safeAsync;
//# sourceMappingURL=Result.js.map

/***/ }),

/***/ 649:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.binary = void 0;
/**
 * A small helper to easily use `process.argv` without dropping context
 *
 * @param cmd a command line parser
 */
function binary(cmd) {
    return {
        ...cmd,
        run(context) {
            var _a;
            const name = cmd.name || context.nodes[1].raw;
            (_a = context.hotPath) === null || _a === void 0 ? void 0 : _a.push(name);
            context.nodes.splice(0, 1);
            context.nodes[0].raw = name;
            context.visitedNodes.add(context.nodes[0]);
            return cmd.run(context);
        },
    };
}
exports.binary = binary;
//# sourceMappingURL=binary.js.map

/***/ }),

/***/ 3930:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createCircuitBreaker = exports.handleCircuitBreaker = exports.versionFlag = exports.helpFlag = void 0;
const types_1 = __nccwpck_require__(6650);
const flag_1 = __nccwpck_require__(7361);
const Result = __importStar(__nccwpck_require__(4413));
const effects_1 = __nccwpck_require__(3656);
exports.helpFlag = (0, flag_1.flag)({
    long: 'help',
    short: 'h',
    type: types_1.boolean,
    description: 'show help',
});
exports.versionFlag = (0, flag_1.flag)({
    long: 'version',
    short: 'v',
    type: types_1.boolean,
    description: 'print the version',
});
function handleCircuitBreaker(context, value, breaker) {
    if (Result.isErr(breaker)) {
        return;
    }
    if (breaker.value === 'help') {
        const message = value.printHelp(context);
        throw new effects_1.Exit({ exitCode: 1, message, into: 'stdout' });
    }
    else if (breaker.value === 'version') {
        const message = value.version || '0.0.0';
        throw new effects_1.Exit({ exitCode: 0, message, into: 'stdout' });
    }
}
exports.handleCircuitBreaker = handleCircuitBreaker;
/**
 * Helper flags that are being used in `command` and `subcommands`:
 * `--help, -h` to show help
 * `--version, -v` to show the current version
 *
 * It is called circuitbreaker because if you have `--help` or `--version`
 * anywhere in your argument list, you'll see the version and the help for the closest command
 */
function createCircuitBreaker(withVersion) {
    return {
        register(opts) {
            exports.helpFlag.register(opts);
            if (withVersion) {
                exports.versionFlag.register(opts);
            }
        },
        helpTopics() {
            const helpTopics = exports.helpFlag.helpTopics();
            if (withVersion) {
                helpTopics.push(...exports.versionFlag.helpTopics());
            }
            return helpTopics;
        },
        async parse(context) {
            const help = await exports.helpFlag.parse(context);
            const version = withVersion
                ? await exports.versionFlag.parse(context)
                : undefined;
            if (Result.isErr(help) || (version && Result.isErr(version))) {
                const helpErrors = Result.isErr(help) ? help.error.errors : [];
                const versionErrors = version && Result.isErr(version) ? version.error.errors : [];
                return Result.err({ errors: [...helpErrors, ...versionErrors] });
            }
            if (help.value) {
                return Result.ok('help');
            }
            else if (version === null || version === void 0 ? void 0 : version.value) {
                return Result.ok('version');
            }
            else {
                return Result.err({
                    errors: [
                        {
                            nodes: [],
                            message: 'Neither help nor version',
                        },
                    ],
                });
            }
        },
    };
}
exports.createCircuitBreaker = createCircuitBreaker;
//# sourceMappingURL=circuitbreaker.js.map

/***/ }),

/***/ 2380:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.command = void 0;
const chalk_1 = __importDefault(__nccwpck_require__(8818));
const utils_1 = __nccwpck_require__(8918);
const circuitbreaker_1 = __nccwpck_require__(3930);
const Result = __importStar(__nccwpck_require__(4413));
/**
 * A command line utility.
 *
 * A combination of multiple flags, options and arguments
 * with a common name and a handler that expects them as input.
 */
function command(config) {
    const argEntries = (0, utils_1.entries)(config.args);
    const circuitbreaker = (0, circuitbreaker_1.createCircuitBreaker)(!!config.version);
    return {
        name: config.name,
        aliases: config.aliases,
        handler: config.handler,
        description: config.description,
        version: config.version,
        helpTopics() {
            return (0, utils_1.flatMap)(Object.values(config.args).concat([circuitbreaker]), (x) => { var _a, _b; return (_b = (_a = x.helpTopics) === null || _a === void 0 ? void 0 : _a.call(x)) !== null && _b !== void 0 ? _b : []; });
        },
        printHelp(context) {
            var _a, _b;
            const lines = [];
            let name = (_b = (_a = context.hotPath) === null || _a === void 0 ? void 0 : _a.join(' ')) !== null && _b !== void 0 ? _b : '';
            if (!name) {
                name = config.name;
            }
            name = chalk_1.default.bold(name);
            if (config.version) {
                name += ' ' + chalk_1.default.dim(config.version);
            }
            lines.push(name);
            if (config.description) {
                lines.push(chalk_1.default.dim('> ') + config.description);
            }
            const usageBreakdown = (0, utils_1.groupBy)(this.helpTopics(), (x) => x.category);
            for (const [category, helpTopics] of (0, utils_1.entries)(usageBreakdown)) {
                lines.push('');
                lines.push(category.toUpperCase() + ':');
                const widestUsage = helpTopics.reduce((len, curr) => {
                    return Math.max(len, curr.usage.length);
                }, 0);
                for (const helpTopic of helpTopics) {
                    let line = '';
                    line += '  ' + (0, utils_1.padNoAnsi)(helpTopic.usage, widestUsage, 'end');
                    line += ' - ';
                    line += helpTopic.description;
                    for (const defaultValue of helpTopic.defaults) {
                        line += chalk_1.default.dim(` [${defaultValue}]`);
                    }
                    lines.push(line);
                }
            }
            return lines.join('\n');
        },
        register(opts) {
            var _a;
            for (const [, arg] of argEntries) {
                (_a = arg.register) === null || _a === void 0 ? void 0 : _a.call(arg, opts);
            }
        },
        async parse(context) {
            var _a;
            if (((_a = context.hotPath) === null || _a === void 0 ? void 0 : _a.length) === 0) {
                context.hotPath.push(config.name);
            }
            const resultObject = {};
            const errors = [];
            for (const [argName, arg] of argEntries) {
                const result = await arg.parse(context);
                if (Result.isErr(result)) {
                    errors.push(...result.error.errors);
                }
                else {
                    resultObject[argName] = result.value;
                }
            }
            const unknownArguments = [];
            for (const node of context.nodes) {
                if (context.visitedNodes.has(node)) {
                    continue;
                }
                if (node.type === 'forcePositional') {
                    // A `forcePositional` node can't really be visited since it has no meaning
                    // other than forcing a positional argument in the parsing phase
                    continue;
                }
                else if (node.type === 'shortOptions') {
                    for (const option of node.options) {
                        if (context.visitedNodes.has(option)) {
                            continue;
                        }
                        unknownArguments.push(option);
                    }
                }
                else {
                    unknownArguments.push(node);
                }
            }
            if (unknownArguments.length > 0) {
                errors.push({
                    message: 'Unknown arguments',
                    nodes: unknownArguments,
                });
            }
            if (errors.length > 0) {
                return Result.err({
                    errors: errors,
                    partialValue: resultObject,
                });
            }
            else {
                return Result.ok(resultObject);
            }
        },
        async run(context) {
            const breaker = await circuitbreaker.parse(context);
            const parsed = await this.parse(context);
            (0, circuitbreaker_1.handleCircuitBreaker)(context, this, breaker);
            if (Result.isErr(parsed)) {
                return Result.err(parsed.error);
            }
            return Result.ok(await this.handler(parsed.value));
        },
    };
}
exports.command = command;
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 3656:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * "Effects" are custom exceptions that can do stuff.
 * The concept comes from React, where they throw a `Promise` to provide the ability to write
 * async code with synchronous syntax.
 *
 * These effects _should stay an implementation detail_ and not leak out of the library.
 *
 * @packageDocumentation
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Exit = void 0;
const chalk_1 = __importDefault(__nccwpck_require__(8818));
/**
 * An effect to exit the program with a message
 *
 * **Why this is an effect?**
 *
 * Using `process.exit` in a program is both a problem:
 * * in tests, because it needs to be mocked somehow
 * * in browser usage, because it does not have `process` at all
 *
 * Also, using `console.log` is something we'd rather avoid and return strings, and if returning strings
 * would be harmful for performance we might ask for a stream to write to:
 * Printing to stdout and stderr means that we don't control the values and it ties us to only use `cmd-ts`
 * with a command line, and again, to mock `stdout` and `stderr` it if we want to test it.
 */
class Exit {
    constructor(config) {
        this.config = config;
    }
    run() {
        const output = this.output();
        output(this.config.message);
        process.exit(this.config.exitCode);
    }
    dryRun() {
        const { into, message, exitCode } = this.config;
        const coloredExit = chalk_1.default.dim(`process exited with status ${exitCode} (${into})`);
        return `${message}\n\n${coloredExit}`;
    }
    output() {
        if (this.config.into === 'stderr') {
            return console.error;
        }
        else {
            return console.log;
        }
    }
}
exports.Exit = Exit;
//# sourceMappingURL=effects.js.map

/***/ }),

/***/ 7205:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorBox = void 0;
const chalk_1 = __importDefault(__nccwpck_require__(8818));
const utils_1 = __nccwpck_require__(8918);
const strip_ansi_1 = __importDefault(__nccwpck_require__(5591));
/**
 * Get the input as highlighted keywords to show to the user
 * with the error that was generated from parsing the input.
 *
 * @param nodes AST nodes
 * @param error A parsing error
 */
function highlight(nodes, error) {
    const strings = [];
    let errorIndex = undefined;
    function foundError() {
        if (errorIndex !== undefined)
            return;
        errorIndex = (0, strip_ansi_1.default)(strings.join(' ')).length;
    }
    if (error.nodes.length === 0)
        return;
    nodes.forEach(node => {
        if (error.nodes.includes(node)) {
            foundError();
            return strings.push(chalk_1.default.red(node.raw));
        }
        else {
            if (node.type === 'shortOptions') {
                let failed = false;
                let s = '';
                for (const option of node.options) {
                    if (error.nodes.includes(option)) {
                        s += chalk_1.default.red(option.raw);
                        failed = true;
                    }
                    else {
                        s += chalk_1.default.dim(option.raw);
                    }
                }
                const prefix = failed ? chalk_1.default.red(`-`) : chalk_1.default.dim('-');
                if (failed) {
                    foundError();
                }
                return strings.push(prefix + s);
            }
            return strings.push(chalk_1.default.dim(node.raw));
        }
    });
    return { colorized: strings.join(' '), errorIndex: errorIndex !== null && errorIndex !== void 0 ? errorIndex : 0 };
}
/**
 * An error UI
 *
 * @param breadcrumbs The command breadcrumbs to print with the error
 */
function errorBox(nodes, errors, breadcrumbs) {
    let withHighlight = [];
    let errorMessages = [];
    for (const error of errors) {
        const highlighted = highlight(nodes, error);
        withHighlight.push({ message: error.message, highlighted });
    }
    let number = 1;
    const maxNumberWidth = String(withHighlight.length).length;
    errorMessages.push(chalk_1.default.red.bold('error: ') +
        'found ' +
        chalk_1.default.yellow(withHighlight.length) +
        ' error' +
        (withHighlight.length > 1 ? 's' : ''));
    errorMessages.push('');
    withHighlight
        .filter(x => x.highlighted)
        .forEach(x => {
        if (!x.highlighted) {
            throw new Error('WELP');
        }
        const pad = ''.padStart(x.highlighted.errorIndex);
        errorMessages.push(`  ${x.highlighted.colorized}`);
        for (const [index, line] of (0, utils_1.enumerate)(x.message.split('\n'))) {
            const prefix = index === 0 ? chalk_1.default.bold('^') : ' ';
            const msg = chalk_1.default.red(`  ${pad} ${prefix} ${line}`);
            errorMessages.push(msg);
        }
        errorMessages.push('');
        number++;
    });
    const withNoHighlight = withHighlight.filter(x => !x.highlighted);
    if (number > 1) {
        if (withNoHighlight.length === 1) {
            errorMessages.push('Along with the following error:');
        }
        else if (withNoHighlight.length > 1) {
            errorMessages.push('Along with the following errors:');
        }
    }
    withNoHighlight.forEach(({ message }) => {
        const num = chalk_1.default.red.bold(`${(0, utils_1.padNoAnsi)(number.toString(), maxNumberWidth, 'start')}.`);
        errorMessages.push(`  ${num} ${chalk_1.default.red(message)}`);
        number++;
    });
    const helpCmd = chalk_1.default.yellow(breadcrumbs.join(' ') + ' --help');
    errorMessages.push('');
    errorMessages.push(chalk_1.default.red.bold('hint: ') + `for more information, try '${helpCmd}'`);
    return errorMessages.join('\n');
}
exports.errorBox = errorBox;
//# sourceMappingURL=errorBox.js.map

/***/ }),

/***/ 7361:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flag = exports.fullFlag = exports.boolean = void 0;
const findOption_1 = __nccwpck_require__(5078);
const type_1 = __nccwpck_require__(838);
const chalk_1 = __importDefault(__nccwpck_require__(8818));
const Result = __importStar(__nccwpck_require__(4413));
const types_1 = __nccwpck_require__(6650);
/**
 * A decoder from `string` to `boolean`
 * works for `true` and `false` only.
 */
exports.boolean = {
    async from(str) {
        if (str === 'true')
            return true;
        if (str === 'false')
            return false;
        throw new Error(`expected value to be either "true" or "false". got: "${str}"`);
    },
    displayName: 'true/false',
    defaultValue: () => false,
};
function fullFlag(config) {
    var _a;
    const decoder = (0, type_1.extendType)(exports.boolean, config.type);
    return {
        description: (_a = config.description) !== null && _a !== void 0 ? _a : config.type.description,
        helpTopics() {
            var _a, _b, _c, _d;
            let usage = `--${config.long}`;
            if (config.short) {
                usage += `, -${config.short}`;
            }
            const defaults = [];
            if (config.env) {
                const env = process.env[config.env] === undefined
                    ? ''
                    : `=${chalk_1.default.italic(process.env[config.env])}`;
                defaults.push(`env: ${config.env}${env}`);
            }
            try {
                const defaultValueFn = (_a = config.defaultValue) !== null && _a !== void 0 ? _a : config.type.defaultValue;
                const defaultValueIsSerializable = (_b = config.defaultValueIsSerializable) !== null && _b !== void 0 ? _b : config.type.defaultValueIsSerializable;
                if (defaultValueFn && defaultValueIsSerializable) {
                    const defaultValue = defaultValueFn();
                    defaults.push('default: ' + chalk_1.default.italic(defaultValue));
                }
            }
            catch (e) { }
            return [
                {
                    category: 'flags',
                    usage,
                    defaults,
                    description: (_d = (_c = config.description) !== null && _c !== void 0 ? _c : config.type.description) !== null && _d !== void 0 ? _d : 'self explanatory',
                },
            ];
        },
        register(opts) {
            opts.forceFlagLongNames.add(config.long);
            if (config.short) {
                opts.forceFlagShortNames.add(config.short);
            }
        },
        async parse({ nodes, visitedNodes, }) {
            var _a, _b;
            const options = (0, findOption_1.findOption)(nodes, {
                longNames: [config.long],
                shortNames: config.short ? [config.short] : [],
            }).filter((x) => !visitedNodes.has(x));
            options.forEach((opt) => visitedNodes.add(opt));
            if (options.length > 1) {
                return Result.err({
                    errors: [
                        {
                            nodes: options,
                            message: 'Expected 1 occurence, got ' + options.length,
                        },
                    ],
                });
            }
            const valueFromEnv = config.env ? process.env[config.env] : undefined;
            let rawValue;
            let envPrefix = '';
            if (options.length === 0 && valueFromEnv !== undefined) {
                rawValue = valueFromEnv;
                envPrefix = `env[${chalk_1.default.italic(config.env)}]: `;
            }
            else if (options.length === 0 &&
                typeof config.type.defaultValue === 'function') {
                try {
                    return Result.ok(config.type.defaultValue());
                }
                catch (e) {
                    const message = `Default value not found for '--${config.long}': ${e.message}`;
                    return Result.err({
                        errors: [{ message, nodes: [] }],
                    });
                }
            }
            else if (options.length === 1) {
                rawValue = (_b = (_a = options[0].value) === null || _a === void 0 ? void 0 : _a.node.raw) !== null && _b !== void 0 ? _b : 'true';
            }
            else {
                return Result.err({
                    errors: [
                        { nodes: [], message: `No value provided for --${config.long}` },
                    ],
                });
            }
            const decoded = await Result.safeAsync(decoder.from(rawValue));
            if (Result.isErr(decoded)) {
                return Result.err({
                    errors: [
                        {
                            nodes: options,
                            message: envPrefix + decoded.error.message,
                        },
                    ],
                });
            }
            return decoded;
        },
    };
}
exports.fullFlag = fullFlag;
function flag(config) {
    return fullFlag({
        type: types_1.boolean,
        ...config,
    });
}
exports.flag = flag;
//# sourceMappingURL=flag.js.map

/***/ }),

/***/ 591:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.identity = void 0;
/**
 * A type "conversion" from any type to itself
 */
function identity() {
    return {
        async from(a) {
            return a;
        },
    };
}
exports.identity = identity;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ 8979:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/**
 * The index module: the entrance to the world of cmd-ts ðŸ˜Ž
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rest = exports.oneOf = exports.union = exports.multioption = exports.multiflag = exports.restPositionals = exports.parse = exports.run = exports.runSafely = exports.dryRun = exports.positional = exports.option = exports.flag = exports.command = exports.binary = exports.extendType = exports.subcommands = void 0;
var subcommands_1 = __nccwpck_require__(1214);
Object.defineProperty(exports, "subcommands", ({ enumerable: true, get: function () { return subcommands_1.subcommands; } }));
var type_1 = __nccwpck_require__(838);
Object.defineProperty(exports, "extendType", ({ enumerable: true, get: function () { return type_1.extendType; } }));
__exportStar(__nccwpck_require__(6650), exports);
var binary_1 = __nccwpck_require__(649);
Object.defineProperty(exports, "binary", ({ enumerable: true, get: function () { return binary_1.binary; } }));
var command_1 = __nccwpck_require__(2380);
Object.defineProperty(exports, "command", ({ enumerable: true, get: function () { return command_1.command; } }));
var flag_1 = __nccwpck_require__(7361);
Object.defineProperty(exports, "flag", ({ enumerable: true, get: function () { return flag_1.flag; } }));
var option_1 = __nccwpck_require__(6183);
Object.defineProperty(exports, "option", ({ enumerable: true, get: function () { return option_1.option; } }));
var positional_1 = __nccwpck_require__(3134);
Object.defineProperty(exports, "positional", ({ enumerable: true, get: function () { return positional_1.positional; } }));
var runner_1 = __nccwpck_require__(3120);
Object.defineProperty(exports, "dryRun", ({ enumerable: true, get: function () { return runner_1.dryRun; } }));
Object.defineProperty(exports, "runSafely", ({ enumerable: true, get: function () { return runner_1.runSafely; } }));
Object.defineProperty(exports, "run", ({ enumerable: true, get: function () { return runner_1.run; } }));
Object.defineProperty(exports, "parse", ({ enumerable: true, get: function () { return runner_1.parse; } }));
var restPositionals_1 = __nccwpck_require__(967);
Object.defineProperty(exports, "restPositionals", ({ enumerable: true, get: function () { return restPositionals_1.restPositionals; } }));
var multiflag_1 = __nccwpck_require__(1093);
Object.defineProperty(exports, "multiflag", ({ enumerable: true, get: function () { return multiflag_1.multiflag; } }));
var multioption_1 = __nccwpck_require__(6686);
Object.defineProperty(exports, "multioption", ({ enumerable: true, get: function () { return multioption_1.multioption; } }));
var union_1 = __nccwpck_require__(7250);
Object.defineProperty(exports, "union", ({ enumerable: true, get: function () { return union_1.union; } }));
var oneOf_1 = __nccwpck_require__(9020);
Object.defineProperty(exports, "oneOf", ({ enumerable: true, get: function () { return oneOf_1.oneOf; } }));
var rest_1 = __nccwpck_require__(3879);
Object.defineProperty(exports, "rest", ({ enumerable: true, get: function () { return rest_1.rest; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1093:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.multiflag = void 0;
const findOption_1 = __nccwpck_require__(5078);
const flag_1 = __nccwpck_require__(7361);
const Result = __importStar(__nccwpck_require__(4413));
/**
 * Like `option`, but can accept multiple options, and expects a decoder from a list of strings.
 * An error will highlight all option occurences.
 */
function multiflag(config) {
    return {
        helpTopics() {
            var _a;
            let usage = `--${config.long}`;
            if (config.short) {
                usage += `, -${config.short}`;
            }
            return [
                {
                    category: 'flags',
                    usage,
                    defaults: [],
                    description: (_a = config.description) !== null && _a !== void 0 ? _a : 'self explanatory',
                },
            ];
        },
        register(opts) {
            opts.forceFlagLongNames.add(config.long);
            if (config.short) {
                opts.forceFlagShortNames.add(config.short);
            }
        },
        async parse({ nodes, visitedNodes, }) {
            var _a, _b;
            const options = (0, findOption_1.findOption)(nodes, {
                longNames: [config.long],
                shortNames: config.short ? [config.short] : [],
            }).filter(x => !visitedNodes.has(x));
            for (const option of options) {
                visitedNodes.add(option);
            }
            const optionValues = [];
            const errors = [];
            for (const option of options) {
                const decoded = await Result.safeAsync(flag_1.boolean.from((_b = (_a = option.value) === null || _a === void 0 ? void 0 : _a.node.raw) !== null && _b !== void 0 ? _b : 'true'));
                if (Result.isErr(decoded)) {
                    errors.push({ nodes: [option], message: decoded.error.message });
                }
                else {
                    optionValues.push(decoded.value);
                }
            }
            if (errors.length > 0) {
                return Result.err({
                    errors,
                });
            }
            const multiDecoded = await Result.safeAsync(config.type.from(optionValues));
            if (Result.isErr(multiDecoded)) {
                return Result.err({
                    errors: [
                        {
                            nodes: options,
                            message: multiDecoded.error.message,
                        },
                    ],
                });
            }
            return multiDecoded;
        },
    };
}
exports.multiflag = multiflag;
//# sourceMappingURL=multiflag.js.map

/***/ }),

/***/ 6686:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.multioption = void 0;
const findOption_1 = __nccwpck_require__(5078);
const Result = __importStar(__nccwpck_require__(4413));
const chalk_1 = __importDefault(__nccwpck_require__(8818));
/**
 * Like `option`, but can accept multiple options, and expects a decoder from a list of strings.
 * An error will highlight all option occurences.
 */
function multioption(config) {
    return {
        helpTopics() {
            var _a, _b, _c, _d;
            const displayName = (_a = config.type.displayName) !== null && _a !== void 0 ? _a : 'value';
            let usage = `--${config.long} <${displayName}>`;
            if (config.short) {
                usage += `, -${config.short}=<${displayName}>`;
            }
            const defaults = [];
            const defaultValueFn = (_b = config.defaultValue) !== null && _b !== void 0 ? _b : config.type.defaultValue;
            if (defaultValueFn) {
                try {
                    const defaultValue = defaultValueFn();
                    if ((_c = config.defaultValueIsSerializable) !== null && _c !== void 0 ? _c : config.type.defaultValueIsSerializable) {
                        defaults.push('default: ' + chalk_1.default.italic(defaultValue));
                    }
                    else {
                        defaults.push('[...optional]');
                    }
                }
                catch (e) { }
            }
            return [
                {
                    category: 'options',
                    usage,
                    defaults,
                    description: (_d = config.description) !== null && _d !== void 0 ? _d : 'self explanatory',
                },
            ];
        },
        register(opts) {
            opts.forceOptionLongNames.add(config.long);
            if (config.short) {
                opts.forceOptionShortNames.add(config.short);
            }
        },
        async parse({ nodes, visitedNodes, }) {
            var _a, _b;
            const options = (0, findOption_1.findOption)(nodes, {
                longNames: [config.long],
                shortNames: config.short ? [config.short] : [],
            }).filter((x) => !visitedNodes.has(x));
            const defaultValueFn = (_a = config.defaultValue) !== null && _a !== void 0 ? _a : config.type.defaultValue;
            if (options.length === 0 && typeof defaultValueFn === 'function') {
                try {
                    return Result.ok(defaultValueFn());
                }
                catch (e) {
                    const message = `Failed to resolve default value for '--${config.long}': ${e.message}`;
                    return Result.err({
                        errors: [
                            {
                                nodes: [],
                                message,
                            },
                        ],
                    });
                }
            }
            for (const option of options) {
                visitedNodes.add(option);
            }
            const optionValues = [];
            const errors = [];
            const flagNodes = [];
            for (const option of options) {
                const providedValue = (_b = option.value) === null || _b === void 0 ? void 0 : _b.node.raw;
                if (providedValue === undefined) {
                    flagNodes.push(option);
                    continue;
                }
                optionValues.push(providedValue);
            }
            if (flagNodes.length > 0) {
                errors.push({
                    nodes: flagNodes,
                    message: `Expected to get a value, found a flag`,
                });
            }
            if (errors.length > 0) {
                return Result.err({ errors });
            }
            const multiDecoded = await Result.safeAsync(config.type.from(optionValues));
            if (Result.isErr(multiDecoded)) {
                return Result.err({
                    errors: [{ nodes: options, message: multiDecoded.error.message }],
                });
            }
            return multiDecoded;
        },
    };
}
exports.multioption = multioption;
//# sourceMappingURL=multioption.js.map

/***/ }),

/***/ 5078:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findOption = void 0;
/**
 * A utility function to find an option in the AST
 *
 * @param nodes AST node list
 * @param opts Long and short names to look up
 */
function findOption(nodes, opts) {
    const result = [];
    for (const node of nodes) {
        if (node.type === 'longOption' && opts.longNames.includes(node.key)) {
            result.push(node);
            continue;
        }
        if (node.type === 'shortOptions' && opts.shortNames.length) {
            for (const option of node.options) {
                if (opts.shortNames.includes(option.key)) {
                    result.push(option);
                }
            }
        }
    }
    return result;
}
exports.findOption = findOption;
//# sourceMappingURL=findOption.js.map

/***/ }),

/***/ 163:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = void 0;
const debug_1 = __importDefault(__nccwpck_require__(8237));
const debug = (0, debug_1.default)('cmd-ts:parser');
/**
 * Create an AST from a token list
 *
 * @param tokens A token list, coming from `tokenizer.ts`
 * @param forceFlag Keys to force as flag. {@see ForceFlag} to read more about it.
 */
function parse(tokens, forceFlag) {
    if (debug.enabled) {
        const registered = {
            shortFlags: [...forceFlag.forceFlagShortNames],
            longFlags: [...forceFlag.forceFlagLongNames],
            shortOptions: [...forceFlag.forceOptionShortNames],
            longOptions: [...forceFlag.forceOptionLongNames],
        };
        debug(`Registered:`, JSON.stringify(registered));
    }
    const nodes = [];
    let index = 0;
    let forcedPositional = false;
    function getToken() {
        return tokens[index++];
    }
    function peekToken() {
        return tokens[index];
    }
    while (index < tokens.length) {
        const currentToken = getToken();
        if (!currentToken)
            break;
        if (currentToken.type === 'argumentDivider') {
            continue;
        }
        if (forcedPositional) {
            let str = currentToken.raw;
            let nextToken = getToken();
            while (nextToken && (nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) !== 'argumentDivider') {
                str += nextToken.raw;
                nextToken = getToken();
            }
            nodes.push({
                type: 'positionalArgument',
                index: currentToken.index,
                raw: str,
            });
            continue;
        }
        if (currentToken.type === 'char') {
            let str = currentToken.raw;
            let nextToken = getToken();
            while (nextToken && (nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) !== 'argumentDivider') {
                str += nextToken.raw;
                nextToken = getToken();
            }
            nodes.push({
                type: 'positionalArgument',
                index: currentToken.index,
                raw: str,
            });
            continue;
        }
        if (currentToken.type === 'longPrefix') {
            let nextToken = getToken();
            if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === 'argumentDivider' || !nextToken) {
                nodes.push({
                    type: 'forcePositional',
                    index: currentToken.index,
                    raw: '--',
                });
                forcedPositional = true;
                continue;
            }
            let key = '';
            while (nextToken &&
                (nextToken === null || nextToken === void 0 ? void 0 : nextToken.raw) !== '=' &&
                (nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) !== 'argumentDivider') {
                key += nextToken.raw;
                nextToken = getToken();
            }
            const parsedValue = parseOptionValue({
                key,
                delimiterToken: nextToken,
                forceFlag: forceFlag.forceFlagLongNames,
                getToken,
                peekToken,
                forceOption: forceFlag.forceOptionLongNames,
            });
            let raw = `--${key}`;
            if (parsedValue) {
                raw += parsedValue.raw;
            }
            nodes.push({
                type: 'longOption',
                key,
                index: currentToken.index,
                raw,
                value: parsedValue,
            });
            continue;
        }
        if (currentToken.type === 'shortPrefix') {
            let keys = [];
            let nextToken = getToken();
            if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === 'argumentDivider' || !nextToken) {
                nodes.push({
                    type: 'positionalArgument',
                    index: currentToken.index,
                    raw: '-',
                });
                continue;
            }
            while (nextToken &&
                (nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) !== 'argumentDivider' &&
                (nextToken === null || nextToken === void 0 ? void 0 : nextToken.raw) !== '=') {
                keys.push(nextToken);
                nextToken = getToken();
            }
            const lastKey = keys.pop();
            const parsedValue = parseOptionValue({
                key: lastKey.raw,
                delimiterToken: nextToken,
                forceFlag: forceFlag.forceFlagShortNames,
                forceOption: forceFlag.forceOptionShortNames,
                getToken,
                peekToken,
            });
            const options = [];
            for (const key of keys) {
                options.push({
                    type: 'shortOption',
                    index: key.index,
                    raw: key.raw,
                    key: key.raw,
                });
            }
            let lastKeyRaw = lastKey.raw;
            if (parsedValue) {
                lastKeyRaw += parsedValue.raw;
            }
            options.push({
                type: 'shortOption',
                index: lastKey.index,
                raw: lastKeyRaw,
                value: parsedValue,
                key: lastKey.raw,
            });
            let optionsRaw = `-${keys.map((x) => x.raw).join('')}${lastKey.raw}`;
            if (parsedValue) {
                optionsRaw += parsedValue.raw;
            }
            const shortOptions = {
                type: 'shortOptions',
                index: currentToken.index,
                raw: optionsRaw,
                options,
            };
            nodes.push(shortOptions);
            continue;
        }
        index++;
        continue;
    }
    if (debug.enabled) {
        const objectNodes = nodes.map((node) => ({ [node.type]: node.raw }));
        debug(`Parsed items:`, JSON.stringify(objectNodes));
    }
    return nodes;
}
exports.parse = parse;
function parseOptionValue(opts) {
    var _a;
    let { getToken, delimiterToken, forceFlag, key, forceOption } = opts;
    const shouldReadKeyAsOption = forceOption.has(key);
    const shouldReadKeyAsFlag = !shouldReadKeyAsOption &&
        (forceFlag.has(key) || ((_a = opts.peekToken()) === null || _a === void 0 ? void 0 : _a.type) !== 'char');
    if (!delimiterToken || (delimiterToken.raw !== '=' && shouldReadKeyAsFlag)) {
        return;
    }
    const delimiter = delimiterToken.raw === '=' ? '=' : ' ';
    const delimiterIndex = delimiterToken.index;
    let nextToken = getToken();
    if (!nextToken) {
        return;
    }
    let value = '';
    const valueIndex = nextToken.index;
    while (nextToken && (nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) !== 'argumentDivider') {
        value += nextToken.raw;
        nextToken = getToken();
    }
    return {
        type: 'optionValue',
        index: delimiterToken.index,
        delimiter: { type: 'delimiter', raw: delimiter, index: delimiterIndex },
        node: { type: 'value', raw: value, index: valueIndex },
        raw: `${delimiter}${value}`,
    };
}
//# sourceMappingURL=parser.js.map

/***/ }),

/***/ 6635:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tokenize = void 0;
const utils_1 = __nccwpck_require__(8918);
/**
 * Tokenize a list of arguments
 *
 * @param strings arguments, based on `process.argv`
 */
function tokenize(strings) {
    let tokens = [];
    let overallIndex = 0;
    const push = (token) => {
        tokens.push(token);
        overallIndex += token.raw.length;
    };
    for (const [stringIndex, string] of (0, utils_1.enumerate)(strings)) {
        const chars = [...string];
        for (let i = 0; i < chars.length; i++) {
            if (chars[i] === '-' && chars[i + 1] === '-') {
                push({ type: 'longPrefix', raw: '--', index: overallIndex });
                i++;
            }
            else if (chars[i] === '-') {
                push({ type: 'shortPrefix', raw: '-', index: overallIndex });
            }
            else {
                push({ type: 'char', raw: chars[i], index: overallIndex });
            }
        }
        if (stringIndex + 1 !== strings.length) {
            push({ type: 'argumentDivider', raw: ' ', index: overallIndex });
        }
    }
    return tokens;
}
exports.tokenize = tokenize;
//# sourceMappingURL=tokenizer.js.map

/***/ }),

/***/ 9020:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oneOf = void 0;
const util_1 = __nccwpck_require__(3837);
/**
 * A union of literals. When you want to take an exact enum value.
 */
function oneOf(literals) {
    const examples = literals.map(x => (0, util_1.inspect)(x)).join(', ');
    return {
        async from(str) {
            const value = literals.find(x => x === str);
            if (!value) {
                throw new Error(`Invalid value '${str}'. Expected one of: ${examples}`);
            }
            return value;
        },
        description: `One of ${examples}`,
    };
}
exports.oneOf = oneOf;
//# sourceMappingURL=oneOf.js.map

/***/ }),

/***/ 6183:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.option = void 0;
const findOption_1 = __nccwpck_require__(5078);
const chalk_1 = __importDefault(__nccwpck_require__(8818));
const Result = __importStar(__nccwpck_require__(4413));
const types_1 = __nccwpck_require__(6650);
function fullOption(config) {
    var _a;
    return {
        description: (_a = config.description) !== null && _a !== void 0 ? _a : config.type.description,
        helpTopics() {
            var _a, _b, _c, _d, _e;
            const displayName = (_a = config.type.displayName) !== null && _a !== void 0 ? _a : 'value';
            let usage = `--${config.long}`;
            if (config.short) {
                usage += `, -${config.short}`;
            }
            usage += ` <${displayName}>`;
            const defaults = [];
            if (config.env) {
                const env = process.env[config.env] === undefined
                    ? ''
                    : `=${chalk_1.default.italic(process.env[config.env])}`;
                defaults.push(`env: ${config.env}${env}`);
            }
            const defaultValueFn = (_b = config.defaultValue) !== null && _b !== void 0 ? _b : config.type.defaultValue;
            if (defaultValueFn) {
                try {
                    const defaultValue = defaultValueFn();
                    if ((_c = config.defaultValueIsSerializable) !== null && _c !== void 0 ? _c : config.type.defaultValueIsSerializable) {
                        defaults.push('default: ' + chalk_1.default.italic(defaultValue));
                    }
                    else {
                        defaults.push('optional');
                    }
                }
                catch (e) { }
            }
            return [
                {
                    category: 'options',
                    usage,
                    defaults,
                    description: (_e = (_d = config.description) !== null && _d !== void 0 ? _d : config.type.description) !== null && _e !== void 0 ? _e : 'self explanatory',
                },
            ];
        },
        register(opts) {
            opts.forceOptionLongNames.add(config.long);
            if (config.short) {
                opts.forceOptionShortNames.add(config.short);
            }
        },
        async parse({ nodes, visitedNodes, }) {
            var _a, _b;
            const options = (0, findOption_1.findOption)(nodes, {
                longNames: [config.long],
                shortNames: config.short ? [config.short] : [],
            }).filter((x) => !visitedNodes.has(x));
            options.forEach((opt) => visitedNodes.add(opt));
            if (options.length > 1) {
                const error = {
                    message: 'Too many times provided. Expected 1, got: ' + options.length,
                    nodes: options,
                };
                return Result.err({ errors: [error] });
            }
            const valueFromEnv = config.env ? process.env[config.env] : undefined;
            const option = options[0];
            let rawValue;
            let envPrefix = '';
            const defaultValueFn = (_a = config.defaultValue) !== null && _a !== void 0 ? _a : config.type.defaultValue;
            if (option === null || option === void 0 ? void 0 : option.value) {
                rawValue = option.value.node.raw;
            }
            else if (valueFromEnv !== undefined) {
                rawValue = valueFromEnv;
                envPrefix = `env[${chalk_1.default.italic(config.env)}]: `;
            }
            else if (!option && typeof defaultValueFn === 'function') {
                try {
                    return Result.ok(defaultValueFn());
                }
                catch (e) {
                    const message = `Default value not found for '--${config.long}': ${e.message}`;
                    return Result.err({
                        errors: [
                            {
                                nodes: [],
                                message,
                            },
                        ],
                    });
                }
            }
            else {
                const raw = (option === null || option === void 0 ? void 0 : option.type) === 'shortOption'
                    ? `-${option === null || option === void 0 ? void 0 : option.key}`
                    : `--${(_b = option === null || option === void 0 ? void 0 : option.key) !== null && _b !== void 0 ? _b : config.long}`;
                return Result.err({
                    errors: [
                        {
                            nodes: options,
                            message: `No value provided for ${raw}`,
                        },
                    ],
                });
            }
            const decoded = await Result.safeAsync(config.type.from(rawValue));
            if (Result.isErr(decoded)) {
                return Result.err({
                    errors: [
                        { nodes: options, message: envPrefix + decoded.error.message },
                    ],
                });
            }
            return Result.ok(decoded.value);
        },
    };
}
function option(config) {
    return fullOption({
        type: types_1.string,
        ...config,
    });
}
exports.option = option;
//# sourceMappingURL=option.js.map

/***/ }),

/***/ 3134:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.positional = void 0;
const Result = __importStar(__nccwpck_require__(4413));
const types_1 = __nccwpck_require__(6650);
const chalk_1 = __importDefault(__nccwpck_require__(8818));
function fullPositional(config) {
    var _a, _b, _c;
    const displayName = (_b = (_a = config.displayName) !== null && _a !== void 0 ? _a : config.type.displayName) !== null && _b !== void 0 ? _b : 'arg';
    return {
        description: (_c = config.description) !== null && _c !== void 0 ? _c : config.type.description,
        helpTopics() {
            var _a, _b, _c, _d;
            const defaults = [];
            const defaultValueFn = (_a = config.defaultValue) !== null && _a !== void 0 ? _a : config.type.defaultValue;
            if (defaultValueFn) {
                try {
                    const defaultValue = defaultValueFn();
                    if ((_b = config.defaultValueIsSerializable) !== null && _b !== void 0 ? _b : config.type.defaultValueIsSerializable) {
                        defaults.push('default: ' + chalk_1.default.italic(defaultValue));
                    }
                    else {
                        defaults.push('optional');
                    }
                }
                catch (e) { }
            }
            const usage = defaults.length > 0 ? `[${displayName}]` : `<${displayName}>`;
            return [
                {
                    category: 'arguments',
                    usage,
                    description: (_d = (_c = config.description) !== null && _c !== void 0 ? _c : config.type.description) !== null && _d !== void 0 ? _d : 'self explanatory',
                    defaults,
                },
            ];
        },
        register(_opts) { },
        async parse({ nodes, visitedNodes, }) {
            var _a;
            const positionals = nodes.filter((node) => node.type === 'positionalArgument' && !visitedNodes.has(node));
            const defaultValueFn = (_a = config.defaultValue) !== null && _a !== void 0 ? _a : config.type.defaultValue;
            let positional = positionals[0];
            if (!positional) {
                if (defaultValueFn) {
                    return Result.ok(defaultValueFn());
                }
                else {
                    return Result.err({
                        errors: [
                            {
                                nodes: [],
                                message: `No value provided for ${displayName}`,
                            },
                        ],
                    });
                }
            }
            visitedNodes.add(positional);
            const decoded = await Result.safeAsync(config.type.from(positional.raw));
            if (Result.isErr(decoded)) {
                return Result.err({
                    errors: [
                        {
                            nodes: [positional],
                            message: decoded.error.message,
                        },
                    ],
                });
            }
            return Result.ok(decoded.value);
        },
    };
}
function positional(config) {
    return fullPositional({
        type: types_1.string,
        ...config,
    });
}
exports.positional = positional;
//# sourceMappingURL=positional.js.map

/***/ }),

/***/ 3879:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rest = void 0;
const Result = __importStar(__nccwpck_require__(4413));
function rest(config) {
    return {
        helpTopics() {
            var _a, _b;
            const displayName = (_a = config === null || config === void 0 ? void 0 : config.displayName) !== null && _a !== void 0 ? _a : 'arg';
            return [
                {
                    usage: `[...${displayName}]`,
                    category: 'arguments',
                    defaults: [],
                    description: (_b = config === null || config === void 0 ? void 0 : config.description) !== null && _b !== void 0 ? _b : 'catches the rest of the values',
                },
            ];
        },
        register() { },
        async parse(context) {
            const visitedNodeIndices = [...context.visitedNodes]
                .map((x) => context.nodes.indexOf(x))
                .filter((x) => x > -1);
            if (visitedNodeIndices.length === 0) {
                return Result.ok([]);
            }
            const maxIndex = Math.max(...visitedNodeIndices);
            const restItems = context.nodes.slice(maxIndex + 1);
            restItems.forEach((node) => context.visitedNodes.add(node));
            return Result.ok(restItems.map((x) => x.raw));
        },
    };
}
exports.rest = rest;
//# sourceMappingURL=rest.js.map

/***/ }),

/***/ 967:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.restPositionals = void 0;
const Result = __importStar(__nccwpck_require__(4413));
const types_1 = __nccwpck_require__(6650);
/**
 * Read all the positionals and decode them using the type provided.
 * Works best when it is the last item on the `command` construct, to be
 * used like the `...rest` operator in JS and TypeScript.
 */
function fullRestPositionals(config) {
    return {
        helpTopics() {
            var _a, _b, _c, _d;
            const displayName = (_b = (_a = config.displayName) !== null && _a !== void 0 ? _a : config.type.displayName) !== null && _b !== void 0 ? _b : 'arg';
            return [
                {
                    usage: `[...${displayName}]`,
                    category: 'arguments',
                    defaults: [],
                    description: (_d = (_c = config.description) !== null && _c !== void 0 ? _c : config.type.description) !== null && _d !== void 0 ? _d : '',
                },
            ];
        },
        register(_opts) { },
        async parse({ nodes, visitedNodes, }) {
            const positionals = nodes.filter((node) => node.type === 'positionalArgument' && !visitedNodes.has(node));
            const results = [];
            let errors = [];
            for (const positional of positionals) {
                visitedNodes.add(positional);
                const decoded = await Result.safeAsync(config.type.from(positional.raw));
                if (Result.isOk(decoded)) {
                    results.push(decoded.value);
                }
                else {
                    errors.push({
                        nodes: [positional],
                        message: decoded.error.message,
                    });
                }
            }
            if (errors.length > 0) {
                return Result.err({
                    errors,
                });
            }
            return Result.ok(results);
        },
    };
}
function restPositionals(config) {
    return fullRestPositionals({
        type: types_1.string,
        ...config,
    });
}
exports.restPositionals = restPositionals;
//# sourceMappingURL=restPositionals.js.map

/***/ }),

/***/ 3120:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = exports.dryRun = exports.runSafely = exports.run = void 0;
const tokenizer_1 = __nccwpck_require__(6635);
const parser_1 = __nccwpck_require__(163);
const errorBox_1 = __nccwpck_require__(7205);
const Result_1 = __nccwpck_require__(4413);
const effects_1 = __nccwpck_require__(3656);
async function run(ap, strings) {
    const result = await runSafely(ap, strings);
    if ((0, Result_1.isErr)(result)) {
        return result.error.run();
    }
    else {
        return result.value;
    }
}
exports.run = run;
/**
 * Runs a command but does not apply any effect
 */
async function runSafely(ap, strings) {
    const hotPath = [];
    const nodes = parseCommon(ap, strings);
    try {
        const result = await ap.run({ nodes, visitedNodes: new Set(), hotPath });
        if ((0, Result_1.isErr)(result)) {
            throw new effects_1.Exit({
                message: (0, errorBox_1.errorBox)(nodes, result.error.errors, hotPath),
                exitCode: 1,
                into: 'stderr',
            });
        }
        else {
            return (0, Result_1.ok)(result.value);
        }
    }
    catch (e) {
        if (e instanceof effects_1.Exit) {
            return (0, Result_1.err)(e);
        }
        throw e;
    }
}
exports.runSafely = runSafely;
/**
 * Run a command but don't quit. Returns an `Result` instead.
 */
async function dryRun(ap, strings) {
    const result = await runSafely(ap, strings);
    if ((0, Result_1.isErr)(result)) {
        return (0, Result_1.err)(result.error.dryRun());
    }
    else {
        return result;
    }
}
exports.dryRun = dryRun;
/**
 * Parse the command as if to run it, but only return the parse result and don't run the command.
 */
function parse(ap, strings) {
    const hotPath = [];
    const nodes = parseCommon(ap, strings);
    return ap.parse({ nodes, visitedNodes: new Set(), hotPath });
}
exports.parse = parse;
function parseCommon(ap, strings) {
    const longFlagKeys = new Set();
    const shortFlagKeys = new Set();
    const longOptionKeys = new Set();
    const shortOptionKeys = new Set();
    const registerContext = {
        forceFlagShortNames: shortFlagKeys,
        forceFlagLongNames: longFlagKeys,
        forceOptionShortNames: shortOptionKeys,
        forceOptionLongNames: longOptionKeys,
    };
    ap.register(registerContext);
    const tokens = (0, tokenizer_1.tokenize)(strings);
    return (0, parser_1.parse)(tokens, registerContext);
}
//# sourceMappingURL=runner.js.map

/***/ }),

/***/ 1214:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.subcommands = void 0;
const positional_1 = __nccwpck_require__(3134);
const chalk_1 = __importDefault(__nccwpck_require__(8818));
const circuitbreaker_1 = __nccwpck_require__(3930);
const Result = __importStar(__nccwpck_require__(4413));
const didyoumean_1 = __importDefault(__nccwpck_require__(5150));
/**
 * Combine multiple `command`s into one
 */
function subcommands(config) {
    const circuitbreaker = (0, circuitbreaker_1.createCircuitBreaker)(!!config.version);
    const type = {
        async from(str) {
            const commands = Object.entries(config.cmds)
                .map(([name, cmd]) => {
                var _a;
                return {
                    cmdName: name,
                    names: [name, ...((_a = cmd.aliases) !== null && _a !== void 0 ? _a : [])],
                };
            });
            const cmd = commands
                .find(x => x.names.includes(str));
            if (cmd) {
                return cmd.cmdName;
            }
            let errorMessage = `Not a valid subcommand name`;
            const closeOptions = (0, didyoumean_1.default)(str, flatMap(commands, x => x.names));
            if (closeOptions) {
                const option = Array.isArray(closeOptions) ? closeOptions[0] : closeOptions;
                errorMessage += `\nDid you mean ${chalk_1.default.italic(option)}?`;
            }
            throw new Error(errorMessage);
        },
    };
    const subcommand = (0, positional_1.positional)({
        displayName: 'subcommand',
        description: 'one of ' + Object.keys(config.cmds).join(', '),
        type,
    });
    function normalizeContext(context) {
        var _a;
        if (((_a = context.hotPath) === null || _a === void 0 ? void 0 : _a.length) === 0) {
            context.hotPath.push(config.name);
        }
        // Called without any arguments? We default to subcommand help.
        if (!context.nodes.some((n) => !context.visitedNodes.has(n))) {
            context.nodes.push({
                type: 'longOption',
                index: 0,
                key: 'help',
                raw: '--help',
            });
        }
    }
    return {
        version: config.version,
        description: config.description,
        name: config.name,
        handler: value => {
            const cmd = config.cmds[value.command];
            return cmd.handler(value.args);
        },
        register(opts) {
            for (const cmd of Object.values(config.cmds)) {
                cmd.register(opts);
            }
            circuitbreaker.register(opts);
        },
        printHelp(context) {
            var _a, _b, _c, _d;
            const lines = [];
            const argsSoFar = (_b = (_a = context.hotPath) === null || _a === void 0 ? void 0 : _a.join(' ')) !== null && _b !== void 0 ? _b : 'cli';
            lines.push(chalk_1.default.bold(argsSoFar + chalk_1.default.italic(' <subcommand>')));
            if (config.description) {
                lines.push(chalk_1.default.dim('> ') + config.description);
            }
            lines.push('');
            lines.push(`where ${chalk_1.default.italic('<subcommand>')} can be one of:`);
            lines.push('');
            for (const key of Object.keys(config.cmds)) {
                const cmd = config.cmds[key];
                let description = (_c = cmd.description) !== null && _c !== void 0 ? _c : '';
                description = description && ' - ' + description + ' ';
                if ((_d = cmd.aliases) === null || _d === void 0 ? void 0 : _d.length) {
                    const aliasTxt = cmd.aliases.length === 1 ? 'alias' : 'aliases';
                    const aliases = cmd.aliases.join(', ');
                    description += chalk_1.default.dim(`[${aliasTxt}: ${aliases}]`);
                }
                const row = chalk_1.default.dim('- ') + key + description;
                lines.push(row.trim());
            }
            const helpCommand = chalk_1.default.yellow(`${argsSoFar} <subcommand> --help`);
            lines.push('');
            lines.push(chalk_1.default.dim(`For more help, try running \`${helpCommand}\``));
            return lines.join('\n');
        },
        async parse(context) {
            var _a;
            normalizeContext(context);
            const parsed = await subcommand.parse(context);
            if (Result.isErr(parsed)) {
                return Result.err({
                    errors: parsed.error.errors,
                    partialValue: {},
                });
            }
            (_a = context.hotPath) === null || _a === void 0 ? void 0 : _a.push(parsed.value);
            const cmd = config.cmds[parsed.value];
            const parsedCommand = await cmd.parse(context);
            if (Result.isErr(parsedCommand)) {
                return Result.err({
                    errors: parsedCommand.error.errors,
                    partialValue: {
                        command: parsed.value,
                        args: parsedCommand.error.partialValue,
                    },
                });
            }
            return Result.ok({
                args: parsedCommand.value,
                command: parsed.value,
            });
        },
        async run(context) {
            var _a;
            normalizeContext(context);
            const parsedSubcommand = await subcommand.parse(context);
            if (Result.isErr(parsedSubcommand)) {
                const breaker = await circuitbreaker.parse(context);
                (0, circuitbreaker_1.handleCircuitBreaker)(context, this, breaker);
                return Result.err({ ...parsedSubcommand.error, partialValue: {} });
            }
            (_a = context.hotPath) === null || _a === void 0 ? void 0 : _a.push(parsedSubcommand.value);
            const cmd = config.cmds[parsedSubcommand.value];
            const commandRun = await cmd.run(context);
            if (Result.isOk(commandRun)) {
                return Result.ok({
                    command: parsedSubcommand.value,
                    value: commandRun.value,
                });
            }
            return Result.err({
                ...commandRun.error,
                partialValue: {
                    command: parsedSubcommand.value,
                    value: commandRun.error.partialValue,
                },
            });
        },
    };
}
exports.subcommands = subcommands;
function flatMap(array, f) {
    const rs = [];
    for (const item of array) {
        rs.push(...f(item));
    }
    return rs;
}
//# sourceMappingURL=subcommands.js.map

/***/ }),

/***/ 838:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extendType = exports.fromFn = exports.typeDef = exports.identity = void 0;
var from_1 = __nccwpck_require__(591);
Object.defineProperty(exports, "identity", ({ enumerable: true, get: function () { return from_1.identity; } }));
/**
 * Get the type definitions or an empty object from a type or a decoding function
 */
function typeDef(from) {
    if (typeof from === 'function') {
        return {};
    }
    else {
        return from;
    }
}
exports.typeDef = typeDef;
/**
 * Get the decoding function from a type or a function
 */
function fromFn(t) {
    if (typeof t === 'function') {
        return t;
    }
    else {
        return t.from;
    }
}
exports.fromFn = fromFn;
/**
 * Extend a type: take a type and use it as a base for another type. Much like using the spread operator:
 * ```
 * const newType = { ...oldType }
 * ```
 * but composes the `from` arguments
 *
 * @param base A base type from `InputA` to `OutputA`
 * @param nextTypeOrDecodingFunction Either an entire `Type<OutputA, AnyOutput>` or just a decoding function from `OutputA` to any type
 */
function extendType(base, nextTypeOrDecodingFunction) {
    const { defaultValue: _defaultValue, from: _from, ...t1WithoutDefault } = base;
    const t2Object = typeDef(nextTypeOrDecodingFunction);
    const t2From = fromFn(nextTypeOrDecodingFunction);
    return {
        ...t1WithoutDefault,
        ...t2Object,
        async from(a) {
            const f1Result = await base.from(a);
            return await t2From(f1Result);
        },
    };
}
exports.extendType = extendType;
//# sourceMappingURL=type.js.map

/***/ }),

/***/ 6650:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.array = exports.optional = exports.boolean = exports.string = exports.number = void 0;
const type_1 = __nccwpck_require__(838);
/**
 * A number type to be used with `option`
 *
 * Throws an error when the provided string is not a number
 */
exports.number = {
    async from(str) {
        const decoded = parseFloat(str);
        if (Number.isNaN(decoded)) {
            throw new Error('Not a number');
        }
        else {
            return decoded;
        }
    },
    displayName: 'number',
    description: 'a number',
};
/**
 * A string type to be used with `option`.
 */
exports.string = {
    ...(0, type_1.identity)(),
    description: 'a string',
    displayName: 'str',
};
/**
 * A boolean type to be used with `flag`.
 */
exports.boolean = {
    ...(0, type_1.identity)(),
    description: 'a boolean',
    displayName: 'true/false',
    defaultValue() {
        return false;
    },
};
/**
 * Makes any type optional, by defaulting to `undefined`.
 */
function optional(t) {
    return {
        ...t,
        defaultValue() {
            return undefined;
        },
    };
}
exports.optional = optional;
/**
 * Transforms any type into an array, useful for `multioption` and `multiflag`.
 */
function array(t) {
    return {
        ...t,
        async from(inputs) {
            return Promise.all(inputs.map((input) => t.from(input)));
        },
    };
}
exports.array = array;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 7250:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.union = void 0;
const type_1 = __nccwpck_require__(838);
const Result = __importStar(__nccwpck_require__(4413));
/**
 * Take one of the types. Merge the metadata from left to right.
 * If nothing matches, prints all the errors.
 */
function union(ts, { combineErrors = errors => errors.join('\n'), } = {}) {
    const merged = Object.assign({}, ...ts.map(x => (0, type_1.typeDef)(x)));
    return {
        ...merged,
        async from(input) {
            const errors = [];
            for (const t of ts) {
                const decoded = await Result.safeAsync((0, type_1.fromFn)(t)(input));
                if (Result.isOk(decoded)) {
                    return decoded.value;
                }
                errors.push(decoded.error.message);
            }
            throw new Error(combineErrors(errors));
        },
    };
}
exports.union = union;
//# sourceMappingURL=union.js.map

/***/ }),

/***/ 8918:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flatten = exports.flatMap = exports.enumerate = exports.entries = exports.groupBy = exports.padNoAnsi = void 0;
const strip_ansi_1 = __importDefault(__nccwpck_require__(5591));
/**
 * @ignore
 */
function padNoAnsi(str, length, place) {
    const noAnsiStr = (0, strip_ansi_1.default)(str);
    if (length < noAnsiStr.length)
        return str;
    const pad = Array(length - noAnsiStr.length + 1).join(' ');
    if (place === 'end') {
        return str + pad;
    }
    else {
        return pad + str;
    }
}
exports.padNoAnsi = padNoAnsi;
/**
 * Group an array by a function that returns the key
 *
 * @ignore
 */
function groupBy(objs, f) {
    var _a;
    const result = {};
    for (const obj of objs) {
        const key = f(obj);
        result[key] = (_a = result[key]) !== null && _a !== void 0 ? _a : [];
        result[key].push(obj);
    }
    return result;
}
exports.groupBy = groupBy;
/**
 * A better typed version of `Object.entries`
 *
 * @ignore
 */
function entries(obj) {
    return Object.entries(obj);
}
exports.entries = entries;
/**
 * Enumerate over a list, to get a pair of [index, value]
 *
 * @ignore
 */
function* enumerate(arr) {
    for (let i = 0; i < arr.length; i++) {
        yield [i, arr[i]];
    }
}
exports.enumerate = enumerate;
/**
 * Array#flatMap polyfill
 *
 * @ignore
 */
function flatMap(xs, fn) {
    const results = [];
    for (const x of xs) {
        results.push(...fn(x));
    }
    return results;
}
exports.flatMap = flatMap;
/**
 * Flatten an array
 *
 * @ignore
 */
function flatten(xs) {
    const results = [];
    for (const x of xs) {
        results.push(...x);
    }
    return results;
}
exports.flatten = flatten;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 7391:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = __nccwpck_require__(8510);

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}

convert.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ 6931:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const conversions = __nccwpck_require__(7391);
const route = __nccwpck_require__(880);

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ 880:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const conversions = __nccwpck_require__(7391);

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ 8510:
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ 4697:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 8222:
/***/ ((module, exports, __nccwpck_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __nccwpck_require__(6243)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 6243:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __nccwpck_require__(4697);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 8237:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __nccwpck_require__(8222);
} else {
	module.exports = __nccwpck_require__(5332);
}


/***/ }),

/***/ 5332:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

const tty = __nccwpck_require__(6224);
const util = __nccwpck_require__(3837);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __nccwpck_require__(9318);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __nccwpck_require__(6243)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 5150:
/***/ ((module) => {

/*

didYouMean.js - A simple JavaScript matching engine
===================================================

[Available on GitHub](https://github.com/dcporter/didyoumean.js).

A super-simple, highly optimized JS library for matching human-quality input to a list of potential
matches. You can use it to suggest a misspelled command-line utility option to a user, or to offer
links to nearby valid URLs on your 404 page. (The examples below are taken from a personal project,
my [HTML5 business card](http://dcporter.aws.af.cm/me), which uses didYouMean.js to suggest correct
URLs from misspelled ones, such as [dcporter.aws.af.cm/me/instagarm](http://dcporter.aws.af.cm/me/instagarm).)
Uses the [Levenshtein distance algorithm](https://en.wikipedia.org/wiki/Levenshtein_distance).

didYouMean.js works in the browser as well as in node.js. To install it for use in node:

```
npm install didyoumean
```


Examples
--------

Matching against a list of strings:
```
var input = 'insargrm'
var list = ['facebook', 'twitter', 'instagram', 'linkedin'];
console.log(didYouMean(input, list));
> 'instagram'
// The method matches 'insargrm' to 'instagram'.

input = 'google plus';
console.log(didYouMean(input, list));
> null
// The method was unable to find 'google plus' in the list of options.
```

Matching against a list of objects:
```
var input = 'insargrm';
var list = [ { id: 'facebook' }, { id: 'twitter' }, { id: 'instagram' }, { id: 'linkedin' } ];
var key = 'id';
console.log(didYouMean(input, list, key));
> 'instagram'
// The method returns the matching value.

didYouMean.returnWinningObject = true;
console.log(didYouMean(input, list, key));
> { id: 'instagram' }
// The method returns the matching object.
```


didYouMean(str, list, [key])
----------------------------

- str: The string input to match.
- list: An array of strings or objects to match against.
- key (OPTIONAL): If your list array contains objects, you must specify the key which contains the string
  to match against.

Returns: the closest matching string, or null if no strings exceed the threshold.


Options
-------

Options are set on the didYouMean function object. You may change them at any time.

### threshold

  By default, the method will only return strings whose edit distance is less than 40% (0.4x) of their length.
  For example, if a ten-letter string is five edits away from its nearest match, the method will return null.

  You can control this by setting the "threshold" value on the didYouMean function. For example, to set the
  edit distance threshold to 50% of the input string's length:

  ```
  didYouMean.threshold = 0.5;
  ```

  To return the nearest match no matter the threshold, set this value to null.

### thresholdAbsolute

  This option behaves the same as threshold, but instead takes an integer number of edit steps. For example,
  if thresholdAbsolute is set to 20 (the default), then the method will only return strings whose edit distance
  is less than 20. Both options apply.

### caseSensitive

  By default, the method will perform case-insensitive comparisons. If you wish to force case sensitivity, set
  the "caseSensitive" value to true:

  ```
  didYouMean.caseSensitive = true;
  ```

### nullResultValue

  By default, the method will return null if there is no sufficiently close match. You can change this value here.

### returnWinningObject

  By default, the method will return the winning string value (if any). If your list contains objects rather
  than strings, you may set returnWinningObject to true.
  
  ```
  didYouMean.returnWinningObject = true;
  ```
  
  This option has no effect on lists of strings.

### returnFirstMatch
  
  By default, the method will search all values and return the closest match. If you're simply looking for a "good-
  enough" match, you can set your thresholds appropriately and set returnFirstMatch to true to substantially speed
  things up.


License
-------

didYouMean copyright (c) 2013-2014 Dave Porter.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License
[here](http://www.apache.org/licenses/LICENSE-2.0).

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
(function() {
  "use strict";

  // The didYouMean method.
  function didYouMean(str, list, key) {
    if (!str) return null;

    // If we're running a case-insensitive search, smallify str.
    if (!didYouMean.caseSensitive) { str = str.toLowerCase(); }

    // Calculate the initial value (the threshold) if present.
    var thresholdRelative = didYouMean.threshold === null ? null : didYouMean.threshold * str.length,
        thresholdAbsolute = didYouMean.thresholdAbsolute,
        winningVal;
    if (thresholdRelative !== null && thresholdAbsolute !== null) winningVal = Math.min(thresholdRelative, thresholdAbsolute);
    else if (thresholdRelative !== null) winningVal = thresholdRelative;
    else if (thresholdAbsolute !== null) winningVal = thresholdAbsolute;
    else winningVal = null;

    // Get the edit distance to each option. If the closest one is less than 40% (by default) of str's length,
    // then return it.
    var winner, candidate, testCandidate, val,
        i, len = list.length;
    for (i = 0; i < len; i++) {
      // Get item.
      candidate = list[i];
      // If there's a key, get the candidate value out of the object.
      if (key) { candidate = candidate[key]; }
      // Gatekeep.
      if (!candidate) { continue; }
      // If we're running a case-insensitive search, smallify the candidate.
      if (!didYouMean.caseSensitive) { testCandidate = candidate.toLowerCase(); }
      else { testCandidate = candidate; }
      // Get and compare edit distance.
      val = getEditDistance(str, testCandidate, winningVal);
      // If this value is smaller than our current winning value, OR if we have no winning val yet (i.e. the
      // threshold option is set to null, meaning the caller wants a match back no matter how bad it is), then
      // this is our new winner.
      if (winningVal === null || val < winningVal) {
        winningVal = val;
        // Set the winner to either the value or its object, depending on the returnWinningObject option.
        if (key && didYouMean.returnWinningObject) winner = list[i];
        else winner = candidate;
        // If we're returning the first match, return it now.
        if (didYouMean.returnFirstMatch) return winner;
      }
    }

    // If we have a winner, return it.
    return winner || didYouMean.nullResultValue;
  }

  // Set default options.
  didYouMean.threshold = 0.4;
  didYouMean.thresholdAbsolute = 20;
  didYouMean.caseSensitive = false;
  didYouMean.nullResultValue = null;
  didYouMean.returnWinningObject = null;
  didYouMean.returnFirstMatch = false;

  // Expose.
  // In node...
  if ( true && module.exports) {
    module.exports = didYouMean;
  }
  // Otherwise...
  else {
    window.didYouMean = didYouMean;
  }

  var MAX_INT = Math.pow(2,32) - 1; // We could probably go higher than this, but for practical reasons let's not.
  function getEditDistance(a, b, max) {
    // Handle null or undefined max.
    max = max || max === 0 ? max : MAX_INT;

    var lena = a.length;
    var lenb = b.length;

    // Fast path - no A or B.
    if (lena === 0) return Math.min(max + 1, lenb);
    if (lenb === 0) return Math.min(max + 1, lena);

    // Fast path - length diff larger than max.
    if (Math.abs(lena - lenb) > max) return max + 1;

    // Slow path.
    var matrix = [],
        i, j, colMin, minJ, maxJ;

    // Set up the first row ([0, 1, 2, 3, etc]).
    for (i = 0; i <= lenb; i++) { matrix[i] = [i]; }

    // Set up the first column (same).
    for (j = 0; j <= lena; j++) { matrix[0][j] = j; }

    // Loop over the rest of the columns.
    for (i = 1; i <= lenb; i++) {
      colMin = MAX_INT;
      minJ = 1;
      if (i > max) minJ = i - max;
      maxJ = lenb + 1;
      if (maxJ > max + i) maxJ = max + i;
      // Loop over the rest of the rows.
      for (j = 1; j <= lena; j++) {
        // If j is out of bounds, just put a large value in the slot.
        if (j < minJ || j > maxJ) {
          matrix[i][j] = max + 1;
        }

        // Otherwise do the normal Levenshtein thing.
        else {
          // If the characters are the same, there's no change in edit distance.
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          }
          // Otherwise, see if we're substituting, inserting or deleting.
          else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // Substitute
                                    Math.min(matrix[i][j - 1] + 1, // Insert
                                    matrix[i - 1][j] + 1)); // Delete
          }
        }

        // Either way, update colMin.
        if (matrix[i][j] < colMin) colMin = matrix[i][j];
      }

      // If this column's minimum is greater than the allowed maximum, there's no point
      // in going on with life.
      if (colMin > max) return max + 1;
    }
    // If we made it this far without running into the max, then return the final matrix value.
    return matrix[lenb][lena];
  }

})();


/***/ }),

/***/ 1621:
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ 5591:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const ansiRegex = __nccwpck_require__(5063);

module.exports = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;


/***/ }),

/***/ 9318:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const os = __nccwpck_require__(2037);
const tty = __nccwpck_require__(6224);
const hasFlag = __nccwpck_require__(1621);

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ 3779:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * WARNING !
 * This file is used as a string by the loader, all the code must be inside the default export function
 * and must not have any dependencies
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
function default_1(root, config, hookRequire) {
    const fs = getBuiltin("fs");
    const os = getBuiltin("os");
    const path = getBuiltin("path");
    const process = getBuiltin("process");
    const tty = getBuiltin("tty");
    const Module = getBuiltin("module");
    function getPath() {
        const stack = new Error().stack;
        const line = stack.split("\n")[4];
        if (config.browser) {
            return line.match(/\@(.*):\d+:\d+/)[1];
        }
        let p = "";
        if (line.endsWith(")")) {
            p = line.match(/\((.*):\d+:\d+\)/)[1];
        }
        else {
            p = line.match(/at (.*):\d+:\d+/)[1];
        }
        return p;
    }
    function hasColor(config) {
        if (!tty) {
            return false;
        }
        return tty.isatty(fd !== null && fd !== void 0 ? fd : 1)
            ? config.color != "never"
            : config.color == "always";
    }
    function getFileDescriptor(config) {
        if (!fs) {
            return null;
        }
        if (!config.logFile) {
            return null;
        }
        return fs.openSync(config.logFile, "w");
    }
    function processHookRequire() {
        if (!Module || !process) {
            return;
        }
        const require = Module.createRequire(process.cwd());
        const { compile } = require(`${root}/compiler.js`);
        const _require = Module.prototype.require;
        const _wrap = Module.wrap;
        // Modify the require function to compile the module before loading it
        const ppfRequire = function (id) {
            if (Module.builtinModules.includes(id)) {
                return _require.apply(this, [id]);
            }
            Module.wrap = function (script) {
                return _wrap(compile(config.wrapperName, script));
            };
            return _require.apply(this, [id]);
        };
        Module.wrap = function (script) {
            return _wrap(compile(config.wrapperName, script));
        };
        Module.prototype.require = Object.assign(ppfRequire, Module.prototype.require);
    }
    if (hookRequire) {
        processHookRequire();
    }
    const fd = getFileDescriptor(config);
    const useColor = hasColor(config);
    const pollutable = new Set(config.pollutable.map((p) => eval(p)));
    function canBePolluted(target, key) {
        if (target === undefined ||
            target === null ||
            key === "__proto__" ||
            typeof key === "symbol") {
            return false;
        }
        let obj = target;
        do {
            if (key !== undefined && Object.hasOwnProperty.call(obj, key)) {
                return false;
            }
            if (pollutable.has(obj.__proto__)) {
                return true;
            }
            obj = Object.getPrototypeOf(obj);
        } while (obj);
        return false;
    }
    /* #region LOGGING */
    function writeToFile(fd, data) {
        if (!fs) {
            return;
        }
        fs.writeSync(fd, data);
    }
    const colorMap = {
        reset: "\x1b[0m",
        PP: "\x1b[34m",
        Bind: "\x1b[35m",
        Elem: "\x1b[32m",
        ForIn: "\x1b[31m",
        IsIn: "\x1b[33m",
        Prop: "\x1b[36m",
    };
    const format = (color, text, wraps = "") => {
        const prefix = wraps.length == 2 ? wraps[0] : "";
        const suffix = wraps.length == 2 ? wraps[1] : "";
        if (!useColor)
            return `${prefix}${text}${suffix}`;
        return `${prefix}${colorMap[color]}${text}${colorMap.reset}${suffix}`;
    };
    const log = (...msg) => {
        const txt = `${format("PP", "PP", "[]")}${msg.join(" ")}`;
        if (fd && os) {
            writeToFile(fd, `${txt}${os.EOL}`);
            return;
        }
        console.log(txt);
    };
    const logged = new Set();
    const logGadget = (expressionType, location, key) => {
        if (!config.log[expressionType])
            return;
        let base = "";
        if (!config.browser && path && process) {
            base = path.relative(process.cwd(), getPath());
        }
        else {
            base = getPath();
        }
        const locInfo = `${location[0]}:${location[1]}`;
        const fullLoc = "\t" + base +
            `:${locInfo}`;
        const gadget = expressionType + (key ? ` ${key}` : "");
        const reportUrlParsed = new URL(reportUrl);
        reportUrlParsed.searchParams.set("url", base);
        reportUrlParsed.searchParams.set("location", locInfo);
        reportUrlParsed.searchParams.set("gadget", gadget);
        reportUrlParsed.searchParams.set("expressionType", expressionType);
        const msg = `${format(expressionType, gadget, "[]")}${fullLoc} ${config.browser ? reportUrlParsed : ""}`;
        if (config.logOnce && logged.has(msg))
            return;
        logged.add(msg);
        log(msg);
    };
    /* #endregion */
    return {
        prop(target, key, loc) {
            if (canBePolluted(target, key)) {
                logGadget("Prop", loc, key.toString());
            }
            return target;
        },
        elem(target, key, loc) {
            if (canBePolluted(target, key)) {
                logGadget("Elem", loc, key.toString());
            }
            return target[key];
        },
        forIn(target, loc) {
            if (canBePolluted(target)) {
                logGadget("ForIn", loc);
            }
            return target;
        },
        isIn(target, key, loc) {
            if (canBePolluted(target, key) && key !== void 0) {
                logGadget("IsIn", loc, key.toString());
            }
            return key in target;
        },
        bind(target, keyList, loc) {
            for (const keys of keyList) {
                let t = target;
                const path = [];
                for (const key of keys) {
                    if (canBePolluted(t, key)) {
                        logGadget("Bind", loc, [...path, key].join("."));
                        break;
                    }
                    else {
                        t = target[key];
                        path.push(key);
                    }
                }
            }
            return target;
        },
    };
}
exports["default"] = default_1;


/***/ }),

/***/ 6733:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const cmd_ts_1 = __nccwpck_require__(8979);
const compile_1 = __importDefault(__nccwpck_require__(601));
const app = (0, cmd_ts_1.subcommands)({
    name: "PP Finder",
    description: "Find prototype pollution gadget in javascript code",
    cmds: {
        compile: compile_1.default
    },
});
(0, cmd_ts_1.run)(app, process.argv.slice(2));


/***/ }),

/***/ 601:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const cmd_ts_1 = __nccwpck_require__(8979);
const fs_1 = __nccwpck_require__(7147);
const promises_1 = __importDefault(__nccwpck_require__(3292));
const path_1 = __importDefault(__nccwpck_require__(1017));
const agent_1 = __importDefault(__nccwpck_require__(3779));
const compiler_1 = __nccwpck_require__(788);
const config_1 = __nccwpck_require__(6373);
const config = (0, config_1.loadConfig)();
function getBuiltinNode(module) {
    return require(module);
}
function getBuiltinBrowser(_) {
    return null;
}
exports["default"] = (0, cmd_ts_1.command)({
    name: "compile",
    description: "Compile the specified file",
    args: {
        file: (0, cmd_ts_1.option)({
            type: cmd_ts_1.string,
            long: "file",
        }),
        wrapperName: (0, cmd_ts_1.option)({
            type: cmd_ts_1.string,
            long: "name",
            short: "w",
            description: 'Wrapper name, (default "Ã¸")',
            defaultValue: () => "Ã¸",
        }),
        output: (0, cmd_ts_1.option)({
            type: (0, cmd_ts_1.optional)(cmd_ts_1.string),
            long: "output",
            short: "o",
            description: 'Output file path',
        }),
        browser: (0, cmd_ts_1.flag)({
            long: "browser",
            short: "b",
            defaultValue: () => false,
            description: "Compile the provided file for the browser",
        }),
        reportUrl: (0, cmd_ts_1.option)({
            type: (0, cmd_ts_1.optional)(cmd_ts_1.string),
            long: "report-url",
            short: "u",
            description: 'Which url to print in the output (required for the burp extension)',
        })
    },
    handler({ file: filePath, wrapperName, output: outputFilePath, browser, reportUrl }) {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const input = filePath === "-" ? process.stdin : (0, fs_1.createReadStream)(filePath);
            input.setEncoding("utf-8");
            let fileData = "";
            try {
                for (var _d = true, input_1 = __asyncValues(input), input_1_1; input_1_1 = yield input_1.next(), _a = input_1_1.done, !_a;) {
                    _c = input_1_1.value;
                    _d = false;
                    try {
                        const chunk = _c;
                        fileData += chunk;
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = input_1.return)) yield _b.call(input_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            config.browser = browser;
            const jsonConfig = JSON.stringify(config);
            const root = JSON.stringify(path_1.default.join(__dirname, ".."));
            const globalKey = browser ? "window" : "globalThis";
            let compiledSource = "";
            compiledSource += `${globalKey}.reportUrl = ("${reportUrl}");`;
            compiledSource += `${globalKey}.getBuiltin = (${browser ? getBuiltinBrowser : getBuiltinNode});`;
            compiledSource += `${globalKey}.${wrapperName} = (${agent_1.default})(${root}, ${jsonConfig}, false);`;
            compiledSource += '\n'.repeat(3);
            compiledSource += (0, compiler_1.compile)(wrapperName, fileData);
            if (!outputFilePath) {
                process.stdout.write(compiledSource);
                return;
            }
            yield promises_1.default.writeFile(outputFilePath, compiledSource);
        });
    },
});


/***/ }),

/***/ 788:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compile = void 0;
const typescript_1 = __importDefault(__nccwpck_require__(4440));
const transformer_1 = __nccwpck_require__(955);
function compile(wrapperName, source) {
    if (source.startsWith("#!")) {
        source = "//" + source;
    }
    const tree = typescript_1.default.createSourceFile("", source, typescript_1.default.ScriptTarget.ESNext, true, typescript_1.default.ScriptKind.JS);
    const printer = typescript_1.default.createPrinter();
    const transformer = (context) => {
        const utils = {
            wrapperName: wrapperName,
            visit(node) {
                return typescript_1.default.visitNode(node, visit);
            },
            createWrapperCall(name, target, params) {
                const pos = typescript_1.default.getLineAndCharacterOfPosition(tree, target.getStart());
                const posArray = typescript_1.default.factory.createArrayLiteralExpression([
                    typescript_1.default.factory.createNumericLiteral(pos.line + 1),
                    typescript_1.default.factory.createNumericLiteral(pos.character + 1),
                ]);
                return typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createIdentifier(`${this.wrapperName}.${name}`), undefined, [...params, posArray]);
            },
        };
        const visit = (node) => {
            for (const transformer of transformer_1.transformers) {
                const newNode = transformer(node, utils);
                if (newNode) {
                    return newNode;
                }
            }
            return typescript_1.default.visitEachChild(node, visit, context);
        };
        return (node) => typescript_1.default.visitNode(node, visit);
    };
    const transformedTree = typescript_1.default.transform(tree, [transformer]);
    const code = transformedTree.transformed.map((n) => printer.printFile(n));
    return code.join("\n");
}
exports.compile = compile;


/***/ }),

/***/ 6373:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadConfig = void 0;
const fs_1 = __importDefault(__nccwpck_require__(7147));
const types_1 = __nccwpck_require__(5077);
const DEFAULT_PPF_CONFIG_FILE_PATH = "./ppf.config.json";
function readFileConfig() {
    const configPath = process.env.PPF_CONFIG_PATH || DEFAULT_PPF_CONFIG_FILE_PATH;
    if (!fs_1.default.existsSync(configPath)) {
        return Object.create(null);
    }
    const content = fs_1.default.readFileSync(configPath, "utf8");
    if (!content.trim()) {
        return Object.create(null);
    }
    const config = JSON.parse(content);
    Object.setPrototypeOf(config, null);
    return config;
}
function parseBool(env) {
    const s = env.toLowerCase().trim();
    if (["no", "false", "0"].includes(s))
        return false;
    return true;
}
function isValidColorOption(env) {
    if (!env)
        return false;
    if (["auto", "always", "never"].includes(env))
        return true;
    return false;
}
function loadEnvConfig(config) {
    if (process.env.PPF_LOGONCE) {
        config.logOnce = parseBool(process.env.PPF_LOGONCE);
    }
    if (process.env.PPF_WRAPPER_NAME) {
        config.wrapperName = process.env.PPF_WRAPPER_NAME;
    }
    if (isValidColorOption(process.env.PPF_COLOR)) {
        config.color = process.env.PPF_COLOR;
    }
    if (process.env.PPF_LOG_FORIN) {
        config.log.ForIn = parseBool(process.env.PPF_LOG_FORIN);
    }
    if (process.env.PPF_LOG_ISIN) {
        config.log.IsIn = parseBool(process.env.PPF_LOG_ISIN);
    }
    if (process.env.PPF_LOG_PROP) {
        config.log.Prop = parseBool(process.env.PPF_LOG_PROP);
    }
    if (process.env.PPF_LOG_ELEM) {
        config.log.Elem = parseBool(process.env.PPF_LOG_ELEM);
    }
    if (process.env.PPF_LOG_BIND) {
        config.log.Bind = parseBool(process.env.PPF_LOG_BIND);
    }
    if (process.env.PPF_LOGFILE) {
        config.logFile = process.env.PPF_LOGFILE;
    }
    if (process.env.PPF_POLLUTABLE) {
        config.pollutable = process.env.PPF_POLLUTABLE.split(",");
    }
    if (process.env.PPF_BROWSER) {
        config.browser = parseBool(process.env.PPF_BROWSER);
    }
    return config;
}
function loadConfig() {
    const fileConfig = readFileConfig();
    const config = loadEnvConfig(types_1.ppFinderConfig.parse(fileConfig));
    return config;
}
exports.loadConfig = loadConfig;


/***/ }),

/***/ 7605:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrowFunctionTransformer = void 0;
const typescript_1 = __importDefault(__nccwpck_require__(4440));
const utils_1 = __nccwpck_require__(4114);
//  (({y}) => ())(x)
const arrowFunctionTransformer = (node, utils) => {
    // Check
    if (!typescript_1.default.isArrowFunction(node) ||
        node.body === undefined ||
        node.parameters.length === 0) {
        return null;
    }
    // Transform
    const { newParameters, newStatements } = (0, utils_1.replaceParams)(node, utils);
    let oldStatements = [];
    const oldBody = utils.visit(node.body);
    if (typescript_1.default.isBlock(oldBody)) {
        oldStatements.push(...oldBody.statements);
    }
    else {
        oldStatements.push(typescript_1.default.factory.createReturnStatement(oldBody));
    }
    return typescript_1.default.factory.updateArrowFunction(node, node.modifiers, node.typeParameters, newParameters, node.type, node.equalsGreaterThanToken, typescript_1.default.factory.createBlock([...newStatements, ...oldStatements]));
};
exports.arrowFunctionTransformer = arrowFunctionTransformer;
exports["default"] = exports.arrowFunctionTransformer;


/***/ }),

/***/ 182:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.elementAccessTransformer = exports.doRequireBind = void 0;
const typescript_1 = __importDefault(__nccwpck_require__(4440));
const utils_1 = __nccwpck_require__(4114);
function doRequireBind(node) {
    if (typescript_1.default.isCallExpression(node.parent)) {
        return !node.parent.arguments.some((x) => x === node);
    }
    return false;
}
exports.doRequireBind = doRequireBind;
// x[y]
const elementAccessTransformer = (node, utils) => {
    // Check
    if ((0, utils_1.isInAssignation)(node) ||
        !typescript_1.default.isElementAccessExpression(node) ||
        node.expression.kind === typescript_1.default.SyntaxKind.SuperKeyword) {
        return null;
    }
    if (typescript_1.default.isPostfixUnaryExpression(node.parent) ||
        typescript_1.default.isPrefixUnaryExpression(node.parent)) {
        return node;
    }
    const requireBind = doRequireBind(node);
    // TODO: Implement a better check than this, this is just a quick fix
    const isAsync = node.getText().includes("await");
    const k = typescript_1.default.factory.createIdentifier(utils.wrapperName + "k");
    const v = typescript_1.default.factory.createIdentifier(utils.wrapperName + "v");
    const nextgen = typescript_1.default.factory.createParenthesizedExpression(typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createParenthesizedExpression(typescript_1.default.factory.createArrowFunction(isAsync
        ? [typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.AsyncKeyword)]
        : [], undefined, [], undefined, typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), typescript_1.default.factory.createBlock([
        typescript_1.default.factory.createVariableStatement(undefined, typescript_1.default.factory.createVariableDeclarationList([
            typescript_1.default.factory.createVariableDeclaration(k, undefined, undefined, node.expression),
        ], typescript_1.default.NodeFlags.Const)),
        typescript_1.default.factory.createVariableStatement(undefined, typescript_1.default.factory.createVariableDeclarationList([
            typescript_1.default.factory.createVariableDeclaration(v, undefined, undefined, node.argumentExpression),
        ], typescript_1.default.NodeFlags.Const)),
        typescript_1.default.factory.createExpressionStatement(utils.createWrapperCall("elem", node.argumentExpression, [k, v])),
        typescript_1.default.factory.createReturnStatement(requireBind
            ? typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createPropertyAccessExpression(typescript_1.default.factory.createElementAccessExpression(k, v), typescript_1.default.factory.createIdentifier("bind")), undefined, [k])
            : typescript_1.default.factory.createElementAccessExpression(k, v)),
    ], true))), undefined, []));
    if (isAsync) {
        return typescript_1.default.factory.createAwaitExpression(nextgen);
    }
    return nextgen;
};
exports.elementAccessTransformer = elementAccessTransformer;
exports["default"] = exports.elementAccessTransformer;


/***/ }),

/***/ 5948:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forInStatementTransformer = void 0;
const typescript_1 = __importDefault(__nccwpck_require__(4440));
// for (let y in x)
const forInStatementTransformer = (node, utils) => {
    // Check
    if (!typescript_1.default.isForInStatement(node)) {
        return null;
    }
    // Transform
    const newNode = utils.createWrapperCall("forIn", node.expression, [
        utils.visit(node.expression),
    ]);
    return typescript_1.default.factory.updateForInStatement(node, utils.visit(node.initializer), newNode, utils.visit(node.statement));
};
exports.forInStatementTransformer = forInStatementTransformer;
exports["default"] = exports.forInStatementTransformer;


/***/ }),

/***/ 9360:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.functionDeclarationTransformer = void 0;
const typescript_1 = __importDefault(__nccwpck_require__(4440));
const utils_1 = __nccwpck_require__(4114);
// function f({y}) {}
const functionDeclarationTransformer = (node, utils) => {
    // Check
    if (!typescript_1.default.isFunctionDeclaration(node) ||
        node.body === undefined ||
        node.parameters.length === 0) {
        return null;
    }
    // Transform
    const { newParameters, newStatements } = (0, utils_1.replaceParams)(node, utils);
    return typescript_1.default.factory.updateFunctionDeclaration(node, node.modifiers, node.asteriskToken, node.name, node.typeParameters, newParameters, node.type, typescript_1.default.factory.createBlock([
        ...newStatements,
        ...utils.visit(node.body).statements,
    ]));
};
exports.functionDeclarationTransformer = functionDeclarationTransformer;
exports["default"] = exports.functionDeclarationTransformer;


/***/ }),

/***/ 9730:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.functionExpressionTransformer = void 0;
const typescript_1 = __importDefault(__nccwpck_require__(4440));
const utils_1 = __nccwpck_require__(4114);
// function f({y}) {}
const functionExpressionTransformer = (node, utils) => {
    // Check
    if (!typescript_1.default.isFunctionExpression(node) ||
        node.body === undefined ||
        node.parameters.length === 0) {
        return null;
    }
    // Transform
    const { newParameters, newStatements } = (0, utils_1.replaceParams)(node, utils);
    return typescript_1.default.factory.updateFunctionExpression(node, node.modifiers, node.asteriskToken, node.name, node.typeParameters, newParameters, node.type, typescript_1.default.factory.createBlock([
        ...newStatements,
        ...utils.visit(node.body).statements,
    ]));
};
exports.functionExpressionTransformer = functionExpressionTransformer;
exports["default"] = exports.functionExpressionTransformer;


/***/ }),

/***/ 37:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InExpressionTransformer = void 0;
const typescript_1 = __importDefault(__nccwpck_require__(4440));
/**
 * TODO: FIXME:
 * // We don't handle this
 * get name() {
 *   if (!this || !(#name in this)) { // transforms to !(Ã¸.isIn(this, #name, [67, 29])) which is not valid javascript
 *     throw new ERR_INVALID_THIS('File');
 *   }
 *
 *   return this.#name;
 * }
 */
// if (y in x)
const InExpressionTransformer = (node, utils) => {
    // Check
    if (!typescript_1.default.isBinaryExpression(node) ||
        node.operatorToken.kind !== typescript_1.default.SyntaxKind.InKeyword) {
        return null;
    }
    // Transform
    return utils.createWrapperCall("isIn", node.right, [
        utils.visit(node.right),
        utils.visit(node.left),
    ]);
};
exports.InExpressionTransformer = InExpressionTransformer;
exports["default"] = exports.InExpressionTransformer;


/***/ }),

/***/ 955:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transformers = void 0;
const arrowFunction_1 = __importDefault(__nccwpck_require__(7605));
const elementAccess_1 = __importDefault(__nccwpck_require__(182));
const forInStatement_1 = __importDefault(__nccwpck_require__(5948));
const functionDeclaration_1 = __importDefault(__nccwpck_require__(9360));
const functionExpression_1 = __importDefault(__nccwpck_require__(9730));
const inExpression_1 = __importDefault(__nccwpck_require__(37));
const objectLiteral_1 = __importDefault(__nccwpck_require__(1690));
const propertyAccess_1 = __importDefault(__nccwpck_require__(9542));
const variableDeclaration_1 = __importDefault(__nccwpck_require__(1437));
exports.transformers = [
    elementAccess_1.default,
    propertyAccess_1.default,
    variableDeclaration_1.default,
    objectLiteral_1.default,
    forInStatement_1.default,
    inExpression_1.default,
    arrowFunction_1.default,
    functionDeclaration_1.default,
    functionExpression_1.default,
];
exports["default"] = exports.transformers;


/***/ }),

/***/ 1690:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteralTransformer = void 0;
const typescript_1 = __importDefault(__nccwpck_require__(4440));
// ({y} = x);
const objectLiteralTransformer = (node, utils) => {
    // Check
    if (!typescript_1.default.isBinaryExpression(node) ||
        node.operatorToken.kind !== typescript_1.default.SyntaxKind.EqualsToken ||
        !typescript_1.default.isObjectLiteralExpression(node.left)) {
        return null;
    }
    // Transform
    function* iterPaths(node, path = []) {
        for (const prop of node.properties) {
            if (typescript_1.default.isShorthandPropertyAssignment(prop)) {
                yield typescript_1.default.factory.createArrayLiteralExpression([
                    ...path,
                    typescript_1.default.factory.createStringLiteral(prop.name.text),
                ]);
            }
            if (typescript_1.default.isPropertyAssignment(prop) && typescript_1.default.isIdentifier(prop.name)) {
                if (typescript_1.default.isIdentifier(prop.initializer)) {
                    yield typescript_1.default.factory.createArrayLiteralExpression([
                        ...path,
                        typescript_1.default.factory.createStringLiteral(prop.name.text),
                    ]);
                }
                if (typescript_1.default.isObjectLiteralExpression(prop.initializer)) {
                    yield* iterPaths(prop.initializer, [
                        ...path,
                        typescript_1.default.factory.createStringLiteral(prop.name.text),
                    ]);
                }
            }
            if (typescript_1.default.isPropertyAssignment(prop) &&
                typescript_1.default.isComputedPropertyName(prop.name)) {
                yield typescript_1.default.factory.createArrayLiteralExpression([
                    ...path,
                    prop.name.expression,
                ]);
            }
        }
    }
    const paths = Array.from(iterPaths(node.left));
    const newNode = utils.createWrapperCall("bind", node.right, [
        utils.visit(node.right),
        typescript_1.default.factory.createArrayLiteralExpression(paths),
    ]);
    return typescript_1.default.factory.updateBinaryExpression(node, utils.visit(node.left), node.operatorToken, newNode);
};
exports.objectLiteralTransformer = objectLiteralTransformer;
exports["default"] = exports.objectLiteralTransformer;


/***/ }),

/***/ 9542:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.propertyAccessTransformer = void 0;
const typescript_1 = __importDefault(__nccwpck_require__(4440));
const utils_1 = __nccwpck_require__(4114);
// x.y
const propertyAccessTransformer = (node, utils) => {
    // Check
    if ((0, utils_1.isInAssignation)(node) ||
        !typescript_1.default.isPropertyAccessExpression(node) ||
        node.expression.kind === typescript_1.default.SyntaxKind.SuperKeyword) {
        return null;
    }
    // Transform
    const newNode = utils.createWrapperCall("prop", node.name, [
        utils.visit(node.expression),
        typescript_1.default.factory.createStringLiteral(node.name.text),
    ]);
    return typescript_1.default.factory.updatePropertyAccessExpression(node, newNode, utils.visit(node.name));
};
exports.propertyAccessTransformer = propertyAccessTransformer;
exports["default"] = exports.propertyAccessTransformer;


/***/ }),

/***/ 4114:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.replaceParams = exports.iterBindingPatternPath = exports.isInAssignation = void 0;
const typescript_1 = __importDefault(__nccwpck_require__(4440));
function isAssignation(operator) {
    const assignationTokens = [
        /*    = */ typescript_1.default.SyntaxKind.EqualsToken,
        /*   += */ typescript_1.default.SyntaxKind.PlusEqualsToken,
        /*   -= */ typescript_1.default.SyntaxKind.MinusEqualsToken,
        /*   *= */ typescript_1.default.SyntaxKind.AsteriskEqualsToken,
        /*  **= */ typescript_1.default.SyntaxKind.AsteriskAsteriskEqualsToken,
        /*   /= */ typescript_1.default.SyntaxKind.SlashEqualsToken,
        /*   %= */ typescript_1.default.SyntaxKind.PercentEqualsToken,
        /*  <<= */ typescript_1.default.SyntaxKind.LessThanLessThanEqualsToken,
        /*  >>= */ typescript_1.default.SyntaxKind.GreaterThanGreaterThanEqualsToken,
        /* >>>= */ typescript_1.default.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
        /*   &= */ typescript_1.default.SyntaxKind.AmpersandEqualsToken,
        /*  &&= */ typescript_1.default.SyntaxKind.AmpersandAmpersandEqualsToken,
        /*   |= */ typescript_1.default.SyntaxKind.BarEqualsToken,
        /*  ||= */ typescript_1.default.SyntaxKind.BarBarEqualsToken,
        /*  ??= */ typescript_1.default.SyntaxKind.QuestionQuestionEqualsToken,
        /*   ^= */ typescript_1.default.SyntaxKind.CaretEqualsToken,
    ];
    return assignationTokens.includes(operator);
}
function isInAssignation(node) {
    return (node.parent &&
        typescript_1.default.isBinaryExpression(node.parent) &&
        isAssignation(node.parent.operatorToken.kind) &&
        node.parent.left == node);
}
exports.isInAssignation = isInAssignation;
function* iterBindingPatternPath(node, path = []) {
    for (const elem of node.elements) {
        const x = typescript_1.default.isShorthandPropertyAssignment(elem);
        if (!elem.propertyName) {
            if (typescript_1.default.isIdentifier(elem.name)) {
                yield typescript_1.default.factory.createArrayLiteralExpression([
                    ...path,
                    typescript_1.default.factory.createStringLiteral(elem.name.text),
                ]);
            }
            continue;
        }
        if (typescript_1.default.isIdentifier(elem.propertyName)) {
            if (typescript_1.default.isIdentifier(elem.name)) {
                yield typescript_1.default.factory.createArrayLiteralExpression([
                    ...path,
                    typescript_1.default.factory.createStringLiteral(elem.propertyName.text),
                ]);
            }
            if (typescript_1.default.isObjectBindingPattern(elem.name)) {
                yield* iterBindingPatternPath(elem.name, [
                    ...path,
                    typescript_1.default.factory.createStringLiteral(elem.propertyName.getText()),
                ]);
            }
        }
        if (typescript_1.default.isComputedPropertyName(elem.propertyName)) {
            yield typescript_1.default.factory.createArrayLiteralExpression([
                ...path,
                elem.propertyName.expression,
            ]);
        }
    }
}
exports.iterBindingPatternPath = iterBindingPatternPath;
function replaceParams(node, utils) {
    const newParameters = [];
    const newDeclarations = [];
    for (const param of node.parameters) {
        if (typescript_1.default.isObjectBindingPattern(param.name)) {
            const paths = Array.from(iterBindingPatternPath(param.name));
            const name = `${utils.wrapperName}_${newDeclarations.length}`;
            const identifier = typescript_1.default.factory.createIdentifier(name);
            const newNode = utils.createWrapperCall("bind", param, [
                identifier,
                typescript_1.default.factory.createArrayLiteralExpression(paths),
            ]);
            newDeclarations.push(typescript_1.default.factory.createVariableDeclaration(param.name, undefined, undefined, newNode));
            newParameters.push(typescript_1.default.factory.updateParameterDeclaration(param, param.modifiers, param.dotDotDotToken, identifier, param.questionToken, param.type, param.initializer));
        }
        else {
            newParameters.push(param);
        }
    }
    let newStatements = [];
    if (newDeclarations.length !== 0) {
        newStatements.push(typescript_1.default.factory.createVariableStatement(undefined, typescript_1.default.factory.createVariableDeclarationList(newDeclarations, typescript_1.default.NodeFlags.Let)));
    }
    return { newParameters, newStatements };
}
exports.replaceParams = replaceParams;


/***/ }),

/***/ 1437:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.variableDeclarationTransformer = void 0;
const typescript_1 = __importDefault(__nccwpck_require__(4440));
const utils_1 = __nccwpck_require__(4114);
// const {y} = x;
const variableDeclarationTransformer = (node, utils) => {
    // Check
    if (!typescript_1.default.isVariableDeclaration(node) ||
        !typescript_1.default.isObjectBindingPattern(node.name) ||
        node.initializer === undefined) {
        return null;
    }
    // Transform
    const paths = Array.from((0, utils_1.iterBindingPatternPath)(node.name));
    const newNode = utils.createWrapperCall("bind", node.initializer, [
        utils.visit(node.initializer),
        typescript_1.default.factory.createArrayLiteralExpression(paths),
    ]);
    return typescript_1.default.factory.updateVariableDeclaration(node, utils.visit(node.name), node.exclamationToken, node.type, newNode);
};
exports.variableDeclarationTransformer = variableDeclarationTransformer;
exports["default"] = exports.variableDeclarationTransformer;


/***/ }),

/***/ 5077:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ppFinderConfig = void 0;
const zod_1 = __nccwpck_require__(8304);
exports.ppFinderConfig = zod_1.z
    .object({
    wrapperName: zod_1.z.string().default("Ã¸").describe("Wrapper name"),
    logOnce: zod_1.z
        .boolean()
        .default(false)
        .describe("Whether to log each gadget once or not"),
    color: zod_1.z
        .enum(["auto", "always", "never"])
        .default("auto")
        .describe("Whether to colorize the output or not"),
    log: zod_1.z
        .object({
        ForIn: zod_1.z.boolean().default(true).describe("Log `for (y in x)` gadgets"),
        IsIn: zod_1.z.boolean().default(true).describe("Log `y in x` gadgets"),
        Prop: zod_1.z.boolean().default(true).describe("Log `x.y` gadgets"),
        Elem: zod_1.z.boolean().default(true).describe("Log `x[y]` gadgets"),
        Bind: zod_1.z.boolean().default(true).describe("Log `{y} = x` gadgets"),
    })
        .default({})
        .describe("Define witch gadgets to log"),
    logFile: zod_1.z
        .string()
        .default("")
        .describe("File to log gadgets to"),
    pollutable: zod_1.z
        .array(zod_1.z.string())
        .default(["Object.prototype"])
        .describe("Pollutable objects"),
    browser: zod_1.z.boolean().default(false).describe("Whether to compile for browser instead of node")
})
    .default({})
    .describe("PP Finder configuration file");


/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3292:
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 6224:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 4440:
/***/ ((module) => {

"use strict";
module.exports = require("typescript");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 8304:
/***/ ((module) => {

"use strict";
module.exports = require("zod");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__nccwpck_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nccwpck_require__(6733);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;